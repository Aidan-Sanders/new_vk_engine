#version 460

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (set = 0, binding = 0, rgba16f) uniform image2D out_frame;

layout (set = 0, binding = 1, rgba16f) uniform readonly image3D cloudtex;

layout (set = 0, binding = 2, r16f) uniform readonly image2D weather;

layout (set = 0, binding = 3) uniform readonly EXTENT
{
    vec2 value;
} extent;

layout (set = 0, binding = 4) uniform readonly CAMERA
{
    vec3 pos;
    vec3 dir;
    vec3 up;
    float fov;
} camera;

layout (set = 0, binding = 5) uniform readonly CLOUD
{
    vec3 centre;
    int size;
    int height;
    int cloudtex_size;
    int weather_size;
    float freq;
    float ambient;
    float sigma_a;
    float sigma_s;
    float step;
    int max_steps;
    float cutoff;
    float density;
    float lambda;
    float temperature;
    vec3 color;
} cloud;

float rand(float x)
{
    return fract(sin(x) * 100000.f) - .5f;
}

vec2 hit_box(vec3 c, vec3 e, vec3 o, vec3 r)
{
    vec3 bmin = c - e * .5f;
    vec3 bmax = c + e * .5f;

    float tmin = (bmin.x - o.x) / r.x;
    float tmax = (bmax.x - o.x) / r.x;

    if (tmin > tmax) { float dummy = tmin; tmin = tmax; tmax = dummy; }

    float tymin = (bmin.y - o.y) / r.y;
    float tymax = (bmax.y - o.y) / r.y;

    if (tymin > tymax) { float dummy = tymin; tymin = tymax; tymax = dummy; }

    if ((tmin > tymax) || (tymin > tmax)) return vec2(-1.f);

    tmin = max(tmin, tymin);
    tmax = min(tmax, tymax);

    float tzmin = (bmin.z - o.z) / r.z;
    float tzmax = (bmax.z - o.z) / r.z;

    if (tzmin > tzmax) { float dummy = tzmin; tzmin = tzmax; tzmax = dummy; }

    if ((tmin > tzmax) || (tzmin > tmax)) return vec2(-1.f);

    return vec2(max(tmin, tzmin), min(tmax, tzmax));
}

float phase(float g, vec3 a, vec3 b)
{
    float cos_theta = dot(a, b);
    float denom = 1.f + g * g - 2.f * g * cos_theta;
    return 1.f / (4.f * 3.14f) * (1.f - g * g) / (denom * sqrt(denom));
}

float fade(float t)
{
	return t * t * t * (t * (t * 6.f - 15.f) + 10.f);
}

float remap(float value, float old_min, float old_max, float new_min, float new_max)
{
    return new_min + (value - old_min) / (old_max - old_min) * (new_max - new_min);
}

float eval_density(vec3 p, vec3 cloud_extent)
{
    // map p to cloud
    vec3 np = p - (cloud.centre - cloud_extent * .5f);
    // float weather = imageLoad(weather, ivec2(floor(np / cloud.size * cloud.weather_size).xz)).x;

    p *= cloud.freq;
    vec4 d = imageLoad(cloudtex, ivec3(floor(p)) & (cloud.cloudtex_size - 1));

    float height = np.y / cloud.height;
    float type = 1.f;

    // stratus
    // if (height > .2f)
    //     type = smoothstep(.23f, .2f, height);
    // if (height < .13f)
    //     type = smoothstep(.1f, .13f, height);

    // cumulus
    if (height > .4f)
        type = smoothstep(.6f, .4f, height);
    if (height < .3f)
        type = smoothstep(.1f, .3f, height);

    // cumulonumbis
    // if (height > .7f)
    //     type = smoothstep(.9f, .7f, height);
    // if (height < .2f)
    //     type = smoothstep(.1f, .2f, height);

    d.r = fade(d.r);
    if (d.r > .3f) return remap(d.r, .3f, 1.f, 0.f, 1.f) * type * height /* weather */;
    return 0.f;
}

/* reference: https://www.shadertoy.com/view/lslGzl */
vec3 linearToneMapping(vec3 color)
{
    float exposure = .6f;
    float gamma = 3.f;
    color = clamp(exposure * color, 0.f, 1.f);
    color = pow(color, vec3(1.f / gamma));
    return color;
}

void main()
{
    int x = int(8 * gl_WorkGroupID.x + gl_LocalInvocationID.x);
    int y = int(8 * gl_WorkGroupID.y + gl_LocalInvocationID.y);

    vec2 res = vec2(8 * gl_NumWorkGroups.x, 8 * gl_NumWorkGroups.y);

    vec3 o = camera.pos;
    vec3 d = camera.dir;

    vec3 left = normalize(cross(camera.up, d));
    vec3 up = normalize(cross(d, left));

    float ux = float(x) / res.x * extent.value.x;
    float uy = float(y) / res.y * extent.value.y;

    float h = tan(radians(camera.fov) / 2.f);
    vec3 upperleft = (o + res.y / 2.f / h * d) + left * extent.value.x / 2.f + up * extent.value.y / 2.f;
    vec3 r = normalize(upperleft - left * ux - up * uy - o);

    vec3 background = /* vec3(0.f) */ mix(vec3(.53f, .81f, .98f), vec3(1.f, 1.f, 1.f), y / extent.value.y);
    vec3 cloud_extent = vec3(cloud.size, cloud.height, cloud.size);

    // intersect
    vec2 t = hit_box(cloud.centre, cloud_extent, o, r);
    if ((t.x < 0.f) && (t.y >= 0.f)) { t.x = 0.f; }

    float transmittance = 1.f;
    vec3 color = vec3(0.f);

    // in volume marching
    if (t.x >= 0.f)
    {
        float sigma_t = cloud.sigma_a + cloud.sigma_s;
        float step = cloud.step;
        int steps = min(int((t.y - t.x) / step), cloud.max_steps) - 1;

        for (int i = 0; i < steps - 1; ++i)
        {
            vec3 p = o + t.x * r;
            float density = eval_density(p, cloud_extent) /* cloud.density*/;
            if (density == 0.f) { t += step+ step * rand(t.y); continue; }
            transmittance *= exp(-step * sigma_t * density);

            // estimate in-scattering to p in volume
            vec3 ld = vec3(0.f, 1.f, 0.f);
            int nsteps = 7;
            float tau = 0.f;

            for (int j = 1; j < nsteps; ++j)
            {
                p += (j * step) * ld;
                tau += eval_density(p, cloud_extent) /* cloud.density */;
            }

            float phase = phase(.6f, ld, r) /* + phase(.3f, ld, r) + phase(-.3f, ld, r) */;
            vec3 li = vec3(phase * exp(-step * sigma_t * tau) /* + cloud.ambient */);
            color += transmittance * cloud.sigma_s * density * li * step;

            t += step + step * rand(t.y);
            if (transmittance < (step + step * rand(t.y))) break;
        }
    }

    color += background * transmittance;
    imageStore(out_frame, ivec2(x, y), vec4(color, 1.f));
    // imageStore(out_frame, ivec2(x, y), vec4(linearToneMapping(color), 1.f));
}